// template script for varying recombination rate

initialize() {
	
	initializeTreeSeq();
	defineConstant("L", 1024); //16 chromosomes each with 64 deleterious loci
	defineConstant("s", 0.4);
	defineConstant("N1", 10000); // recipient population size
	defineConstant("N2", 1000); // donor population size
	defineConstant("genomeSize",1e9);
	initializeMutationRate(0);
	initializeMutationType("m1", 0.5, "f", 0);
	m1.convertToSubstitution = F;
	initializeGenomicElementType("g1", m1, 1.0);
	initializeGenomicElement(g1, 0, L-1);
	defineConstant("baseRate", 1e-8);
	
	// create recombination rate vector
	fourChromRates = c(c(baseRate*c(0.1,0.1,0.5,0.5)*c(1,5,5,10),0.5),c(baseRate*c(0.25,0.25,0.75,0.75)*c(1,5,5,10),0.5),c(baseRate*c(1,1,2.5,2.5)*c(1,5,5,10),0.5),c(baseRate*c(2.5,2.5,5,5)*c(1,5,5,10),0.5));
	fourChromRates2 = c(c(baseRate*c(0.1,0.1,0.5,0.5)*c(1,5,5,10),0.5),c(baseRate*c(0.25,0.25,0.75,0.75)*c(1,5,5,10),0.5),c(baseRate*c(1,1,1.5,1.5)*c(1,5,5,10),0.5),c(baseRate*c(1.5,1.5,2,2)*c(1,5,5,10),0.5));
	
	allChromRates = rep(c(fourChromRates,fourChromRates2),2);
	allChromRates = allChromRates[0:(length(allChromRates)-2)];
	
	// create breakpoint vector
	breaks =  c((1:4*16)-1,64);
	for(i in 1:15)
		breaks =  c(breaks, c((1:4*16)-1,64)+64*i);
	breaks = breaks[0:(length(breaks)-2)]; //minus 2 bc we don't need 0.5 recomb at end
	
	defineConstant("outPath",
		"results/multi-scale/");
	
	
	// if running on command line, seed needs to be passed in as command line parameter
	if (exists("slimgui")) {
		defineConstant("seed", 1);
	}
	
	setSeed(seed);
	
	effectiveRates = NULL;
	for(i in 0:(length(allChromRates)-1)){
		
		if(allChromRates[i] != 0.5)
			r = (genomeSize/L)*allChromRates[i];
		else
			r = allChromRates[i];
		effectiveRates = c(effectiveRates,r);
		}
	
	
	
	
	initializeRecombinationRate(effectiveRates, breaks);
	// use the line below in gui for visualizing recombination map, gui only displays limited range
	//initializeRecombinationRate(allChromRates,breaks);

}

1 {sim.addSubpop("p1", N1);
	sim.addSubpop("p2", N2);
	
	// add deleterious mutations (sel. coefficient is zero bc fitness calculated l8r)
	p2.genomes.addNewMutation(m1, 0, 0:(L-1));
	
	// migration
	p1.setMigrationRates(p2, 0.5);
	
	catn('startread');
	catn('replicate' + seed);

}


//calculate fitness
1:1000 late() {
	inds = p1.individuals;
	introgressed = inds.countOfMutationsOfType(m1);
	//catn(mean(introgressed/(2*L)));
	inds.fitnessScaling = 1.0 - (introgressed/(2*L))*s;
	
	// print ancestry per time 	
	//pos = p1.genomes.positionsOfMutationsOfType(m1);
	//catn(sum(pos < 32)/(32*2*N1) + "," + sum(pos >= 32 & pos < 64)/(32*2*N1) + "," + sum(pos >= 64 & pos < 96)/(32*2*N1) + "," + sum(pos >= 96)/(32*2*N1));

}


2 {p2.setSubpopulationSize(0);}


// output

2 late() {
	sim.treeSeqOutput(outPath + "/replicate" + seed + "_gen0002.trees"); }

5 late() {
	sim.treeSeqOutput(outPath + "/replicate" + seed + "_gen0005.trees"); }

10 late() {
	sim.treeSeqOutput(outPath + "/replicate" + seed + "_gen0010.trees"); }

50 late() {
	sim.treeSeqOutput(outPath + "/replicate" + seed + "_gen0050.trees"); }

100 late() {
	sim.treeSeqOutput(outPath + "/replicate" + seed + "_gen0100.trees"); }

500 late() {
	sim.treeSeqOutput(outPath + "/replicate" + seed + "_gen0500.trees"); }

750 late() {
	sim.treeSeqOutput(outPath + "/replicate" + seed + "_gen0750.trees"); }

1000 late() {
	sim.treeSeqOutput(outPath + "/replicate" + seed + "_gen1000.trees"); }

// set up a simple neutral simulation
// template script for looking into the effect of varying (a) pop size, (b) fine-scale recomb, (c) number of chroms
initialize() {
	initializeTreeSeq();
	defineConstant("L", 1000);
	defineConstant("s", 0.4);
	defineConstant("N1", 10000); // recipient population size
	defineConstant("N2", 1000); // donor population size
	defineConstant("numChroms",1);
	defineConstant("baseRate",1e-8);
	defineConstant("genomeSize",1e9);
	initializeMutationRate(0);
	initializeMutationType("m1", 0.5, "f", 0);
	m1.convertToSubstitution = F;
	initializeGenomicElementType("g1", m1, 1.0);
	initializeGenomicElement(g1, 0, L-1);
	
	rates = c(baseRate/10, baseRate*10);
	effectiveRates = (genomeSize/L)*rates;
	ends = c(499,999);
	
	initializeRecombinationRate(effectiveRates, ends);

}

1 {sim.addSubpop("p1", N1);
	sim.addSubpop("p2", N2);
	
	// add deleterious mutations (sel. coefficient is zero bc fitness calculated l8r)
	p2.genomes.addNewMutation(m1, 0, 0:(L-1));
	
	// migration
	p1.setMigrationRates(p2, 0.5);

}


//calculate fitness
1: late() {
	inds = p1.individuals;
	introgressed = inds.countOfMutationsOfType(m1);
	inds.fitnessScaling = 1.0 - (introgressed/(2*L))*s;

}

2 {p2.setSubpopulationSize(0);}


500 late() { sim.treeSeqOutput("~/workspace/results/selection-against-introgression/intra-chrom.trees"); }


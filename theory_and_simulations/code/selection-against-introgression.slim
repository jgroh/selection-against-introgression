// set up a simple neutral simulation
// template script for looking into the effect of varying (a) pop size, (b) fine-scale recomb, (c) number of chroms
initialize() {
	initializeTreeSeq();
	defineConstant("L", 1000);
	defineConstant("s", 0.4);
	defineConstant("N1", 10000); // recipient population size
	defineConstant("N2", 1000); // donor population size
	defineConstant("numChroms",10);
	defineConstant("baseRate",1e-8);
	defineConstant("genomeSize",1e9);
	//defineConstant("effRate",(genomeSize/L) * baseRate);
	initializeMutationRate(0);
	initializeMutationType("m1", 0.5, "f", 0);
	m1.convertToSubstitution = F;
	initializeGenomicElementType("g1", m1, 1.0);
	initializeGenomicElement(g1, 0, L-1);
	
	chromRates = sort(rgamma(numChroms, mean=1e-8, shape=0.1)); // define chromosome-wide rates
	
	// define within-chromosome rate variation, 10 regions per chromosome
	rates = float(length = 10*numChroms);
	
	for(i in 0:(numChroms-1))
		rates[c(0:9)+ 10*i] = chromRates[i];
		//rates[c(0:9)+ 10*i] = rgamma(10, mean= chromRates[i], shape = 1);
	
	// generate recombination breakpoints
	/////////////////////////////////////
	
	// chromosome breakpoints
	chromEnds=NULL;
	for (chromBreak in 1:numChroms)
		chromEnds=c(chromEnds,asInteger(chromBreak*L/numChroms-1),asInteger(chromBreak*L/numChroms));
		
	// within-chromosome breakpoints: for each chromosome, uniformly generate 9 recombination breakpoints (corresponding to 10 variable-rate regions within each chromosome)
	ends = NULL; //empty vector
	for(i in 0:(numChroms-1))
		ends = c( ends,
		sort(
		sample((chromEnds[i*2]-98):(chromEnds[i*2]-1), 9)),
		chromEnds[i*2], chromEnds[i*2+1] );
	
	effectiveRates = (genomeSize/L)*rates;
	//effectiveRates = rates;
	
	// add recombination 0.5 between chromosomes
	finalRates = NULL;
	for(i in 0:9)
		finalRates = c(finalRates, effectiveRates[c(0:9)+ 10*i], 0.5);
	
	ends = sort(ends);
	initializeRecombinationRate(finalRates, ends);

}

1 {sim.addSubpop("p1", N1); 
	sim.addSubpop("p2", N2);
	
	// add deleterious mutations (sel. coefficient is zero bc fitness calculated in callback)
	p2.genomes.addNewMutation(m1, 0, 0:(L-1));
	
	// migration
	p1.setMigrationRates(p2, 0.1);
	
	}
			
1: late() {
	inds = p1.individuals;
	introgressed = inds.countOfMutationsOfType(m1);
	inds.fitnessScaling = 1.0 - (introgressed/(2*L))*s;
   
	}
	
2 {p2.setSubpopulationSize(0);}


//fitness(NULL) { //gets called once per individual per generation, AFTER late events
//	introgressed = sum(c(genome1,genome2).countOfMutationsOfType(m1));
//	return 1.0 - (introgressed/(2*L))*s;
//}

//1: late() {
//	p1g = p1.genomes;
//	inds_introgressed = p1g.countOfMutationsOfType(m1);
//	catn("Average hybrid ancestry:" + mean(inds_introgressed)/(L));
	
//}


100 late() { sim.treeSeqOutput("~/workspace/selection-against-introgression/inter-chrom-variation-only.trees"); }

